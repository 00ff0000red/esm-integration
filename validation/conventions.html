<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Conventions &#8212; WebAssembly 1.0</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="WebAssembly 1.0" href="../index.html" />
    <link rel="up" title="Validation" href="index.html" />
    <link rel="next" title="Instructions" href="instructions.html" />
    <link rel="prev" title="Validation" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <script type="text/javascript">MathJax.Hub.Config({TeX: {MAXBUFFER: 10*1024}})</script><script type="text/javascript">MathJax.Hub.Config({TeX: {MAXBUFFER: 10*1024}})</script><body role="document">
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/placeholder.jpg" alt="Logo"/>
            </a></p><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../syntax/index.html">Structure</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Validation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="instructions.html">Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="modules.html">Modules</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../instantiation/index.html">Instantiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../execution/index.html">Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../instructions/index.html">Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../binary/index.html">Binary Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-properties/index.html">Appendix: Formal Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-algorithm/index.html">Appendix: Validation Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-textual/index.html">Appendix: Text Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix-names/index.html">Appendix: Name Section</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../syntax/instrindex.html">Index of Instructions</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="../genindex.html">Index</a></li>
    
    <li class="toctree-l1"><a href="../_download/WebAssembly.pdf">Download as PDF</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="conventions">
<span id="index-0"></span><h1>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h1>
<p>Validation checks that a WebAssembly module is well-formed.
Only valid modules can be <span class="xref std std-ref">instantiated</span>.</p>
<p>Validity is defined by a <em>type system</em> over the <a class="reference internal" href="../syntax/conventions.html#syntax"><span class="std std-ref">abstract syntax</span></a> of both instructions and modules.
For each piece of abstract syntax, there is a typing rule that specifies the constraints that apply to it.
All rules are given in two <em>equivalent</em> forms:</p>
<ol class="arabic simple">
<li>In <em>prose</em>, describing the meaning in intuitive form.</li>
<li>In <em>formal notation</em>, describing the rule in mathematical form.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The prose and formal rules are equivalent,
so that understanding of the formal notation is <em>not</em> required to read this specification.
The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.</p>
</div>
<p>In both cases, the rules are formulated in a <em>declarative</em> manner.
That is, they only formulate the constraints, they do not define an algorithm.
A sound and complete algorithm for type-checking instruction sequences according to this specification is provided in the <span class="xref std std-ref">appendix</span>.</p>
<span class="target" id="context"></span><div class="section" id="contexts">
<span id="index-1"></span><h2>Contexts<a class="headerlink" href="#contexts" title="Permalink to this headline">¶</a></h2>
<p>Validity of an individual definition is specified relative to a <em>context</em>,
which collects relevant information about the surrounding <a class="reference internal" href="../syntax/modules.html#syntax-module"><span class="std std-ref">module</span></a> and other definitions in scope:</p>
<ul class="simple">
<li><em>Types</em>: the list of types defined in the current module.</li>
<li><em>Functions</em>: the list of functions declared in the current module, represented by their function type.</li>
<li><em>Tables</em>: the list of tables declared in the current module, represented by their table type.</li>
<li><em>Memories</em>: the list of memories declared in the current module, represented by their memory type.</li>
<li><em>Globals</em>: the list of globals declared in the current module, represented by their global type.</li>
<li><em>Locals</em>: the list of locals declared in the current function (including parameters), represented by their value type.</li>
<li><em>Labels</em>: the stack of labels accessible from the current position, represented by their result type.</li>
</ul>
<p>In other words, a context contains a sequence of suitable <span class="xref std std-ref">types</span> for each <a class="reference internal" href="../syntax/modules.html#syntax-index"><span class="std std-ref">index space</span></a>,
describing each defined entry in that space.
Locals and labels are only used for validating <a class="reference internal" href="../syntax/instructions.html#syntax-instr"><span class="std std-ref">instructions</span></a> in <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function bodies</span></a>, and are left empty elsewhere.
The label stack is the only part of the context that changes as validation of an instruction sequence proceeds.</p>
<p>It is convenient to define contexts as <a class="reference internal" href="../syntax/conventions.html#syntax-record"><span class="std std-ref">records</span></a> <span class="math">\(C\)</span> with abstract syntax:</p>
<div class="math">
\[\begin{split}\begin{array}{llll}
\def\mathdef885#1{{}}\mathdef885{(context)} &amp; C &amp;::=&amp;
  \begin{array}[t]{l&#64;{~}ll}
  \{ &amp; \mathsf{types} &amp; \href{../syntax/types.html#syntax-functype}{\mathit{functype}}^\ast, \\
     &amp; \mathsf{funcs} &amp; \href{../syntax/types.html#syntax-functype}{\mathit{functype}}^\ast, \\
     &amp; \mathsf{tables} &amp; \href{../syntax/types.html#syntax-tabletype}{\mathit{tabletype}}^\ast, \\
     &amp; \mathsf{mems} &amp; \href{../syntax/types.html#syntax-memtype}{\mathit{memtype}}^\ast, \\
     &amp; \mathsf{globals} &amp; \href{../syntax/types.html#syntax-globaltype}{\mathit{globaltype}}^\ast, \\
     &amp; \mathsf{locals} &amp; \href{../syntax/types.html#syntax-valtype}{\mathit{valtype}}^\ast, \\
     &amp; \mathsf{labels} &amp; \href{../syntax/types.html#syntax-resulttype}{\mathit{resulttype}}^\ast ~\} \\
  \end{array}
\end{array}\end{split}\]</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fields of a context are not defined as <a class="reference internal" href="../syntax/values.html#syntax-vec"><span class="std std-ref">vectors</span></a>,
since their lengths are not bounded by the maximum vector size.</p>
</div>
<p>In addition to field access <span class="math">\(C.\mathsf{field}\)</span> the following notation is adopted for manipulating contexts:</p>
<ul class="simple">
<li>When spelling out a context, empty fields are omitted.</li>
<li><span class="math">\(C,\mathsf{field}\,A^\ast\)</span> denotes the same context as <span class="math">\(C\)</span> but with the elements <span class="math">\(A^\ast\)</span> prepended to its <span class="math">\(\mathsf{field}\)</span> component sequence.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This notation is defined to <em>prepend</em> not <em>append</em>.
It is only used in situations where the original <span class="math">\(C.\mathsf{field}\)</span> is either empty
or <span class="math">\(\mathsf{field}\)</span> is <span class="math">\(\mathsf{labels}\)</span>.
In the latter case adding to the front is desired
because the <a class="reference internal" href="../syntax/modules.html#syntax-labelidx"><span class="std std-ref">label index</span></a> space is indexed relatively, that is, in reverse order of addition.</p>
</div>
</div>
<div class="section" id="textual-notation">
<h2>Textual Notation<a class="headerlink" href="#textual-notation" title="Permalink to this headline">¶</a></h2>
<p>Validation is specified by stylised rules for each relevant part of the <a class="reference internal" href="../syntax/conventions.html#syntax"><span class="std std-ref">abstract syntax</span></a>.
The rules not only state constraints defining when a phrase is valid,
they also classify it with a type.
A phrase <span class="math">\(A\)</span> is said to be &#8220;valid with type <span class="math">\(T\)</span>&#8221;,
if all constraints expressed by the respective rules are met.
The form of <span class="math">\(T\)</span> depends on what <span class="math">\(A\)</span> is.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For example, if <span class="math">\(A\)</span> is a <a class="reference internal" href="../syntax/modules.html#syntax-func"><span class="std std-ref">function</span></a>,
then  <span class="math">\(T\)</span> is a <a class="reference internal" href="../syntax/types.html#syntax-functype"><span class="std std-ref">function type</span></a>;
for an <span class="math">\(A\)</span> that is a <a class="reference internal" href="../syntax/modules.html#syntax-global"><span class="std std-ref">global</span></a>,
<span class="math">\(T\)</span> is a <a class="reference internal" href="../syntax/types.html#syntax-globaltype"><span class="std std-ref">global type</span></a>;
and so on.</p>
</div>
<p>The rules implicitly assume a given <a class="reference internal" href="#context"><span class="std std-ref">context</span></a> <span class="math">\(C\)</span>.
In some places, this context is locally extended to a context <span class="math">\(C'\)</span> with additional entries.
The formulation &#8220;Under context <span class="math">\(C'\)</span>, ... <em>statement</em> ...&#8221; is adopted to express that the following statement must apply under the assumptions embodied in the extended context.</p>
</div>
<div class="section" id="formal-notation">
<h2>Formal Notation<a class="headerlink" href="#formal-notation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section gives a brief explanation of the notation for specifying typing rules formally.
For the interested reader, a more thorough introduction can be found in respective text books. <a class="footnote-reference" href="#tapl" id="id1">[1]</a></p>
</div>
<p>The proposition that a phrase <span class="math">\(A\)</span> has a respective type <span class="math">\(T\)</span> is written <span class="math">\(A : T\)</span>.
In general, however, typing is dependent on the context <span class="math">\(C\)</span>.
To express this explicitly, the complete form is a <em>judgement</em> <span class="math">\(C \vdash A : T\)</span>,
which says that <span class="math">\(A : T\)</span> holds under the assumptions encoded in <span class="math">\(C\)</span>.</p>
<p>The formal typing rules use a standard approach for specifying type systems, rendering them into <em>deduction rules</em>.
Every rule has the following general form:</p>
<div class="math">
\[\frac{
  \mathit{premise}_1 \qquad \mathit{premise}_2 \qquad \dots \qquad \mathit{premise}_n
}{
  \mathit{conclusion}
}\]</div>
<p>Such a rule is read as a big implication: if all premises hold, then the conclusion holds.
Some rules have no premises; they are <em>axioms</em> whose conclusion holds unconditionally.
The conclusion always is a judgment <span class="math">\(C \vdash A : T\)</span>,
and there is one respective rule for each relevant construct <span class="math">\(A\)</span> of the abstract syntax.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For example, the typing rule for the <a class="reference internal" href="../syntax/instructions.html#syntax-instr-numeric"><span class="std std-ref">instruction</span></a> <span class="math">\(\mathsf{i32.add}\)</span> can be given as an axiom:</p>
<div class="math">
\[\frac{
}{
  C \vdash \mathsf{i32.add} : [\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}~\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}] \to [\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}]
}\]</div>
<p>The instruction is always valid with type <span class="math">\([\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}~\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}] \to [\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}\)</span>]
(saying that it consumes two <span class="math">\(\href{../syntax/types.html#syntax-valtype}{\mathsf{i32}}\)</span> values and produces one),
independent from any side conditions.</p>
<p>An instruction like <span class="math">\(\mathsf{get\_local}\)</span> can be typed as follows:</p>
<div class="math">
\[\frac{
  C.\mathsf{local}[x] = t
}{
  C \vdash \mathsf{get\_local}~x : [] \to [t]
}\]</div>
<p>Here, the premise enforces that the immediate <a class="reference internal" href="../syntax/modules.html#syntax-localidx"><span class="std std-ref">local index</span></a> <span class="math">\(x\)</span> exists in the context.
The instruction produces a value of its respective type <span class="math">\(t\)</span>
(and does not consume any values).
If <span class="math">\(C.\mathsf{local}[x]\)</span> does not exist then the premise does not hold,
and the instruction is ill-typed.</p>
<p>Finally, a <a class="reference internal" href="../syntax/instructions.html#syntax-instr-control"><span class="std std-ref">structured</span></a> instruction requires
a recursive rule, where the premise is itself a typing judgement:</p>
<div class="math">
\[\frac{
  C,\mathsf{label}\,[t^?] \vdash \href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast : [] \to [t^?]
}{
  C \vdash \mathsf{block}~[t^?]~\href{../syntax/instructions.html#syntax-instr}{\mathit{instr}}^\ast~\mathsf{end} : [] \to [t^?]
}\]</div>
<p class="last">A <span class="math">\(\mathsf{block}\)</span> instruction is only valid when the instruction sequence in its body is.
Moreover, the result type must match the block&#8217;s annotation <span class="math">\(t^?\)</span>.
If so, then the <span class="math">\(\mathsf{block}\)</span> instruction has the same type as the body.
Inside the body an additional label of the same type is available,
which is expressed by locally extending the context <span class="math">\(C\)</span> with the additional label information for the premise.</p>
</div>
<table class="docutils footnote" frame="void" id="tapl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For example: Benjamin Pierce. <a class="reference external" href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a>. The MIT Press 2002</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017, WebAssembly Community Group.
      
    </div>

    

    
  </body>
</html>